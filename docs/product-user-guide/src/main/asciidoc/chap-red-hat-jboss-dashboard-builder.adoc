[id='_chap_red_hat_jboss_dashboard_builder']
= Red Hat JBoss Dashboard Builder

Red Hat JBoss Dashboard Builder application supports Business Activity Monitoring (BAM) using visualization tools for monitoring metrics, such as Key Performance Indicators and process statuses. With the Dashboard Builder, you can compose custom business dashboards by mixing data coming from various data sources and displaying them as graphs or tables, as well as creating custom title navigation.

Dashboard Builder is connected to the local JBoss BPM Suite engine by default, and acquires the data for its JBoss BPM Suite Dashboard indicators. Data sources contain custom data that can be used to create data sets. Dashboard Builder can then use these data sets to create custom perspectives. The following types of data sets are supported:

Databases::
This uses an SQL query for obtaining data from an external database.

CSV files::
Operating over a CSV file allows the data provider to obtain all data from the file.

JAR files::
For advanced users, JavaBeans or JAR files can be added to the Business Central distribution.

Elastic Search::
Data available in the Elastic Search storage system.
 
To access the Dashboard Builder, click *Menu* -> *Design* -> *Dashboards* in Business Central.


[id='_process_and_task_dashboard']
== Process & Task Dashboard

The *Process & Task Dashboard* contains several performance indicators monitoring the {PRODUCT} Execution Engine. The data used by the dashboard comes from two tables of the database belonging to the engine: `processinstancelog` and ``bamtasksummary``.

.The Process & Task Dashboard Main Screen
image::processandtaskdashboard.png[]
//REDO THIS SCREEN SHOT

Every time the information stored into the database is updated, the data becomes automatically available to the dashboard indicators.

[NOTE]
====
All the metrics are generic and do not belong to any specific business process.
However, it is possible to modify or extend the generic dashboard for your own use: the {PRODUCT} Process Dashboard can serve as a template for building a custom dashboard, which works with both data of the {PRODUCT} Engine and data coming from your own business domain.
====

At the top of the *Process & Task Dashboard*
 main screen, you can choose whether you want to view indicators related to *Processes* or *Tasks*.

You can filter the data by clicking the charts, for example if you want to select a particular process or status.
Every time a filter is applied, all the indicators are automatically updated and synchronized to show the selected criteria.
The following picture shows an example dashboard with the `Sales` process and the `Active` status selected.

.Active Sales Processes
image::activesalesprocesses.png[]


It is also possible to display a list of instances at any time by clicking the *Show Instances*
 link in the upper right hand corner of the screen.
You can then switch to the original screen by clicking the *Show Dashboard*
 link.

.Process Instances List
image::processinstancelist.png[]


You can sort the instances by clicking any column header.
Details about a particular instance are shown on the right side of the page after selecting a row.
Note that the displayed details are not editable.
If you want to manage a process instance, go to *Process Management* -> *Process Instances*
 in Business Central.

.Process Instance Details Panel
image::processinstancedetails.png[]


[id='_sect_data_sources']
== Data Sources

Red Hat JBoss Dashboard Builder can be connected to an external database, either using the container's JNDI data source or connecting directly using the JDBC driver to access the database.
Connections to databases can be configured in workspace _Showcase_ on page __External Connections__.
After you have established the connection to the database, you need to create a data provider that will collect the data from the database and allow you to visualize it as an indicator in the dashboard area of a page.

When connecting to CSV files to acquire data, the connection is established directly through the data provider.

Note that Red Hat JBoss Dashboard Builder
 makes use of its own local internal database to store its local data.
This database is read-only for Dashboard Builder, but is accessible from outside.

=== Connecting to Data Sources


You can connect either to a JNDI data source, that is, a data source set up and accessible from the application container, or directly to the data source as a custom data source, if the application container has the correct JDBC driver deployed.

To connect to an external data source, do the following:

. Make sure the data source is up and running and that the application server has access to the data source. (Check the driver, the login credentials, etc. In Red Hat JBoss EAP 6, you can do so in the Management Console under *Subsystems* -> *Connector* -> *Datasources*)
. In Dashboard Builder, on the Tree Menu (by default located on the of the Showcase page), go to *Administration* -> *External connections*.
. On the displayed External Connection panel, click the *New DataSource* image:5456.png[] button.
. Select the data source type (JNDI or Custom DataSource) and provide the respective data source parameters below.

ifdef::BPMS[]
If you wish the jBPM Dashboard to use the new data source, modify also the respective data providers (jBPM Count Processes, jBPM Process Summary, jBPM Task Summary). Note that the data source needs to have access to jBPM history.
endif::BPMS[]

[id='_security_considerations']
=== Security Considerations

[IMPORTANT]
====
When creating an external datasource using JBoss Dashboard Builder, it needs to use the local connection so that the user can be passed through.
Otherwise, with a connection that uses <host>:<port>, every user would have the same virtual database (VDB) permissions.
====


////
//Not sure if any of this section is still relevant or useful for the new dashboard builder in LA onwards.

[id='_building_a_dashboard_for_large_volumes_of_data']
=== Building a Dashboard for Large Volumes of Data


You can connect Red Hat JBoss Dashboard Builder to external databases and load data for generating reports and charts. Generally, if the volume of data is small (up to 2MB), Red Hat JBoss Dashboard Builder preloads the data into (local) memory and uses this data for report and chart generation.
However, in case of large volumes of data, it is not possible to load the entire data set into the Dashboard Builder's local memory.

Based on the volume of data you are dealing with, you can choose to query the database to build a dashboard report in any one of the following strategies:

* The in-memory strategy
+
The in-memory strategy is to create a data provider that loads all the required data from the database by executing a single SQL query on the relevant tables, into the Dashboard Builder's memory.
In this case, every indicator on the Dashboard Builder shares the same data set.
When you use filters from the Dashboard Builder user interface to access specific data from this data set, the Dashboard Builder fetches the data from the internal memory and does not execute another SQL query again on the database.
This strategy has a simple data retrieval logic as it deals with creating a single data provider.
As all the data set properties are available to you at once, it allows you to configure KPIs faster.
However, this approach is not suitable for large data sets as it would lead to poor performance.
+
* The native strategy
+
The native approach is to create a data provider for every indicator in the Dashboard Builder and does not require loading all the data into the internal memory at once.
So each time you use a filter from the Dashboard Builder user interface, the corresponding SQL queries get executed and fetches the required data from the database.
So there is no data in the Dashboard Builder's internal memory.
This strategy works best in case of large volumes of data, however it needs proper indexing on the database tables.
Also, setting up data providers for multiple KPIs is complicated as compared to creating a single data provider in case of in-memory strategy.


.Example
Let us consider a case when you want to create a stock exchange dashboard comprising the following charts and reports:

* Bar chart for Average price per company
* Area chart for Sales price evolution
* Pie chart for Companies per country
* Table report for Stock prices at closing date


For these charts and reports, let us assume that the Dashboard Builder accesses data from the following tables:

* Company: Comprising columns ID, NAME, and COUNTRY.
* Stock: Comprising columns ID, ID_COMPANY, PRICE_PER_SHARE, and CLOSING_DATE.


For the in-memory strategy of building a dashboard, the following SQL query fetches all the required data from these two tables:

[source]
----
SELECT C.NAME, C.COUNTRY, S.PRICE_PER_SHARE, S.CLOSING_DATE
  FROM COMPANY C JOIN STOCK S ON (C.ID=S.ID_COMPANY)
----

The output of this query is saved in the Dashboard Builder's local memory.
The Dashboard accesses this data every time a filter is run.

On the other hand, if you are using the native strategy for huge volumes of data, an SQL query is executed on every filter request made by the Dashboard Builder and corresponding data is fetched from the database.
In this case here is how each filter accesses the database:

* For the bar chart on __Average price per company__, the following SQL query is executed:
+

[source]
----
SELECT C.NAME, AVG(S.PRICE_PER_SHARE)
  FROM COMPANY C JOIN STOCK S ON (C.ID=S.ID_COMPANY)
  WHERE {sql_condition, optional, c.country, country}
  AND {sql_condition, optional, c.name, name}
  GROUP BY C.NAME
----
* For the area chart on __Sales price evolution__, the following SQL query is executed:
+

[source]
----
SELECT S.CLOSING_DATE, AVG(S.PRICE_PER_SHARE)
  FROM COMPANY C JOIN STOCK S ON (C.ID=S.ID_COMPANY)
  WHERE {sql_condition, optional, c.country, country}
  AND {sql_condition, optional, c.name, name}
  GROUP BY CLOSING_DATE
----
* For the pie chart on __Companies per country__, the following SQL query is executed:
+

[source]
----
SELECT COUNTRY, COUNT(ID)
  FROM COMPANY
  WHERE {sql_condition, optional, country, country}
  AND {sql_condition, optional, name, name}
  GROUP BY COUNTRY
----
* For the table report on __Stock prices at closing date__, the following SQL query is executed:
+

[source]
----
SELECT C.NAME, C.COUNTRY, S.PRICE_PER_SHARE, S.CLOSING_DATE
  FROM COMPANY C JOIN STOCK S ON (C.ID=S.ID_COMPANY)
  WHERE {sql_condition, optional, c.country, country}
  AND {sql_condition, optional, c.name, name}
----


For each of these queries, you need to create a separate SQL data provider.

In the examples above, each KPI delegates the filter and group by operations to the database through the `{sql_condition}` clauses.
The signature of the `{sql_condition}` clause is the following:
[source]
----
  {sql_condition, [optional | required], [db column], [filter property]}
----
Here,

* optional: This indicates that if there is no filter for the given property, then the condition is ignored.
* required: This indicates that if there is no filter for the given property, then the SQL returns no data.
* db column: This indicates the database column where the current filter is applied.
* filter property: This indicates the selected UI filter property.


When a filter occurs in the UI, the Dashboard Builder parses and injects all the SQL data providers referenced by the KPIs into these SQL statements.
Every time a filter occurs in the UI, the Dashboard Builder gets all the SQL data providers referenced by the KPIs and injects the current filter selections made by the user into these SQLs.

////



////
// Really not sure if this is still relevant

[id='_dashbuilder_data_model']
== Dashboard Builder Data Model

The following image illustrates the Dashboard Builder data model:

image::dashbuilder_db_schema.png[]

NOTE: Dashboard Builder data model stores only metadata, _not_ actual runtime data.

.Dashboard Builder Data Model
[cols="1,1,1", options="header"] 
|===
|Table
|Attributes
|Description

|`dashb_data_source`
|`dbid`, `ds_type`, `name`, `jndi_path`, `ds_url`, `jdbc_driver_class`, `user_name`, `passwd`, `test_query`
|Stores data source instances, either JNDI or JDBC.

|`dashb_data_source_table`
|`dbid`, `name`, `data_source`, `selected`
|Currently not used. Stores a set of tables available for a given data source.

|`dashb_data_source_column`
|`dbid`, `name`, `sql_type`, `data_source`, `table_name`, `primary_key`, `identity1`
|Currently not used. Stores a set of columns within a table.

|`dashb_permission`
|`id_permission`, `principal_class`, `principal_name`, `permission_class`, `permission_resource`, `permission_action`, `permission_readonly`
|Stores permissions for different user interface resources (workspaces, pages, panels, and graphic resources).

|`dashb_graphic_resource`
|`dbid`, `workspace_id`, `section_id`, `panel_id`, `id`, `resource_type`, `zip`, `status`, `last_modified`
|Stores graphic resource definitions (envelopes, layouts, and skins).

|`dashb_workspace`
|`id_workspace`, `look`, `envelope`, `url`, `default_workspace`, `home_search_mode`
|Stores workspace instances.

|`dashb_workspace_home`
|`id_workspace`, `id_role`, `id_section`
|Stores a home page for each role.

|`dashb_workspace_parameter`
|`id_workspace`, `id_parameter`, `language`, `value`
|Stores workspace-related parameters.

|`dashb_allowed_panel`
|`id_workspace`, `id_panel_provider`
|Stores a set of panel types a workspace can use.

|`dashb_section`
|`dbid`, `id_section`, `id_workspace`, `id_template`, `position`, `visible`, `region_spacing`, `panel_spacing`, `id_parent`, `url`, `skin`, `envelope`
|Refers to the `dashb_workspace` table.

|`dashb_section_i18n`
|`id_section`, `language`, `title`
|Stores information for internationalization and localization.

|`dashb_panel_instance`
|`dbid`, `id_instance`, `id_workspace`, `provider`, `serialization`
|Stores reusable panel instances. It is _not_ tied to any specific page.

|`dashb_panel`
|`dbid`, `id_panel`, `id_instance`, `id_section`, `id_region`, `position`
|Stores page panels. Refers to the `dashb_panel_instance` and `dashb_section` tables. It _is_ tied to a particular page and layout region.

|`dashb_panel_parameter`
|`dbid`, `id_parameter`, `id_instance`, `value`, `language`
|Stores page panels and _is_ tied to a particular page and layout region.

|`dashb_panel_html`
|`dbid`, `id_instance`
|Stores an HTML panel definition.

|`dashb_panel_html_i18n`
|`id_text`, `language`, `html_text`
|Stores information for internationalization and localization.

|`dashb_data_provider`
|`id`, `code`, `provider_uid`, `provider_xml`, `data_properties_xml`, `can_edit`, `can_edit_properties`, `can_delete`
|Stores data provider definitions (SQL and CSV).

|`dashb_data_provider_i18n`
|`id_data_provider`, `language`, `description`
|Stores information for internationalization and localization.

|`dashb_kpi`
|`id`, `id_data_provider`, `code`, `displayer_uid`, `displayer_xml`
|Stores all types of KPI definitions (pie, bar, line, and table).

|`dashb_kpi_i18n`
|`id_kpi`, `language`, `description`
|Stores information for internationalization and localization.

|`dashb_installed_module`
|`name`, `version`
|Stores installed or imported modules used for automatic importing of assets.

|`dashb_cluster_node`
|`id_node`, `node_address`, `startup_time`, `node_status`
|Stores running nodes and is needed for cluster setups.
|===

////